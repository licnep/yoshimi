# data file for the Fltk User Interface Designer (fluid)
version 1.0110 
header_name {.h} 
code_name {.cc}
comment {WidgetPDial.h} {not_in_source in_header
} 

comment {WidgetPDial.cc} {in_source not_in_header
} 

comment {
Original ZynAddSubFX author Nasca Octavian Paul
Copyright (C) 2002-2005 Nasca Octavian Paul
Copyright 2009-2010, Alan Calvert

This file is part of yoshimi, which is free software: you can redistribute
it and/or modify it under the terms of version 2 of the GNU General Public
License as published by the Free Software Foundation.

yoshimi is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.   See the GNU General Public License (version 2 or
later) for more details.

You should have received a copy of the GNU General Public License along with
yoshimi; if not, write to the Free Software Foundation, Inc., 51 Franklin
Street, Fifth Floor, Boston, MA  02110-1301, USA.

This file is a derivative of the ZynAddSubFX original, modified October 2010
} {in_source in_header
} 

decl {\#include <FL/Fl_Dial.H>
    \#include <FL/Fl_Menu_Window.H>
    \#include "Misc/MiscFuncs.h"
    \#include "Params/ParamChangeFunc.h"} {public global
} 

decl {\#include <cmath>
    \#include <FL/fl_draw.H>
    \#include <FL/Fl_Tooltip.H>
    \#include <stdio.h>
    \#include <FL/Fl_Group.H>
    \#include<Misc/SynthEngine.h>} {global
} 

decl {\#include <stdio.h>
    \#include <FL/Fl_Menu.H>
    \#include "Params/midiController.h"
    \#include "MidiControllerUI.h"} {global
} 

class TipWin {open : {public Fl_Menu_Window, MiscFuncs}
} {
  Function {TipWin():Fl_Menu_Window(1,1)} {} {
    code {tip.clear();
        tip = string("X.XX");
        set_override();
        end();} {}
  }
  Function {draw(void)} {return_type void
  } {
    code {draw_box(FL_BORDER_BOX, 0, 0, w(), h(), Fl_Color(175));
        fl_color(FL_BLACK);
        fl_font(labelfont(), labelsize());
        if(textmode)
            fl_draw(text.c_str(), 3, 3, w() - 6, h() - 6,
                    Fl_Align(FL_ALIGN_LEFT|FL_ALIGN_WRAP));
        else
            fl_draw(tip.c_str(), 3, 3, w() - 6, h() - 6,
                    Fl_Align(FL_ALIGN_LEFT|FL_ALIGN_WRAP));} {}
  }
  Function {value(float f)} {return_type void
  } {
    code {tip.clear();
        tip = asString(f);
        textmode = false;
        // Recalc size of window
        fl_font(labelfont(), labelsize());
        int W = w(), H = h();
        fl_measure(tip.c_str(), W, H, 0);
        W += 8;
        size(W, H);
        redraw();} {}
  }
  Function {setText(string c)} {return_type void
  } {
    code {text = c;
        textmode = true;
        // Recalc size of window
        fl_font(labelfont(), labelsize());
        int W = w(), H = h();
        fl_measure(text.c_str(), W, H, 0);
        W += 8;
        size(W, H);
        redraw();} {}
  }
  Function {setTextmode()} {return_type void
  } {
    code {textmode=true;
        // Recalc size of window
        fl_font(labelfont(), labelsize());
        int W = w(), H = h();
        fl_measure(text.c_str(), W, H, 0);
        W += 8;
        size(W, H);
        redraw();} {}
  }
  decl {string tip;} {}
  decl {bool textmode;} {}
  decl {string text;} {}
} 

class WidgetPDial {open : {public Fl_Dial}
} {
  Function {WidgetPDial(int x, int y, int w, int h, const char *label=0):Fl_Dial(x,y,w,h,label)} {open
  } {
    code {callback(value_cb, (void*)this);
        Fl_Group *save = Fl_Group::current();
        tipwin = new TipWin();
        tipwin->hide();
        Fl_Group::current(save);
        oldvalue = 0.0f;
        pos = false;
        textset = false;
        midiControlled = false;
        Controllable = false;
        justCreated = true;} {}
  }
  Function {~WidgetPDial()} {} {
    code {list<midiController>::iterator i;
        for(i=synth->assignedMidiControls.begin();i!=synth->assignedMidiControls.end();i++) {
            if (i->knob==this) i->removeDialPointer();
        }
        delete tipwin;} {}
  }
  Function {callback(Fl_Callback* cb)} {} {
    code {Fl_Widget::callback(cb);} {}
  }
  Function {handle(int event)} {open return_type int
  } {
    code {double dragsize, v, min = minimum(), max = maximum();
        int my;
        switch (event)
        {
            case FL_PUSH:
                 oldvalue = value();
                 //right click menu:
		 if ( Fl::event_button() == FL_RIGHT_MOUSE ) {
                        if (Controllable) {
                            Fl_Menu_Item rclick_menu[] = {
			        { "Reset", 0, reset},
                                { "Midi Learn",  0, stampa, (void*)1 },
				{ 0 }
			    };
                            if (midiControlled) {
                                Fl_Menu_Item item = {"Remove midi control", 0, stampa, (void*)1};
                                rclick_menu[1] = item;
                            }
                            const Fl_Menu_Item *m = rclick_menu->popup(Fl::event_x(), Fl::event_y(), 0, 0, 0);
			    if ( m ) m->do_callback(this, m->user_data());
                         } else {
                            Fl_Menu_Item rclick_menu[] = {
			        { "Reset", 0, reset},
				{ 0 }
			    };
                            const Fl_Menu_Item *m = rclick_menu->popup(Fl::event_x(), Fl::event_y(), 0, 0, 0);
			    if ( m ) m->do_callback(this, m->user_data());
                         }
                    }
		return 1;
            case FL_DRAG:
                 if(!pos)
                 {
                     tipwin->position(Fl::event_x_root(), Fl::event_y_root() + 20);
                     pos = true;
                 }
                 tipwin->value(value());
                 tipwin->show();
                 my = -(Fl::event_y() - y() - h() / 2);

                 dragsize = 200.0f;
                 if (Fl::event_state(FL_BUTTON1) == 0)
                     dragsize *= 10;
                 v = oldvalue + my / dragsize * (max - min);
                 if (v < min)
                     v = min;
                 else if (v > max)
                     v = max;

                 // printf("%d   %g    %g\\n",my,v,oldvalue);
                 value(v);
                 value_damage();
                 if (this->when() != 0)
                     do_callback();
                 return 1;
                 break;
            case FL_ENTER:
                 if(textset)
                 {
                     if(!pos)
                     {
                         tipwin->position(Fl::event_x_root(), Fl::event_y_root() + 20);
                         pos = true;
                     }
                     tipwin->setTextmode();
                     tipwin->show();
                     return 1;
                 }
                 break;
            case FL_HIDE:
            case FL_LEAVE:
                 tipwin->hide();
                 pos = false;
                 break;
            case FL_RELEASE:
                 tipwin->hide();
                 pos = false;
                 if (this->when() == 0)
                     do_callback();
                 return 1;
                 break;
        }
        return 0;} {}
  }
  Function {drawgradient(int cx,int cy,int sx,double m1,double m2)} {return_type void
  } {
    code {for (int i = (int)(m1 * sx); i < (int)(m2 * sx); ++i)
        {
            double tmp = 1.0 - powf( i * 1.0f / sx, 2.0f);
            pdialcolor(140 + (int) (tmp * 90), 140 + (int)(tmp * 90), 140 + (int)(tmp * 100));
            fl_arc(cx + sx / 2 - i / 2, cy + sx / 2 - i / 2, i, i, 0, 360);
        }} {}
  }
  Function {draw(void)} {return_type void
  } {
    code {checkSetParameter();
        int cx = x(), cy = y(), sx = w(), sy = h();
        // clears the button face
        pdialcolor(190, 190, 200);
        fl_pie(cx - 1, cy - 1, sx + 2, sy + 2, 0, 360);

        // Draws the button face (gradinet)
        drawgradient(cx, cy, sx, 0.5, 1.0);

        double val = (value() - minimum()) / (maximum() - minimum());

        // draws the scale
        pdialcolor(220, 220, 250);
        double a1 = angle1(), a2 = angle2();
        for (int i = 0; i < 12; ++i)
        {
            double a = -i / 12.0 * 360.0 - val * (a2 - a1) - a1;
            fl_pie(cx, cy, sx, sy, a + 270 - 3, a + 3 + 270);
        }
        drawgradient(cx, cy, sx, 0.0, 0.75);
        // draws the value
        double a = -(a2 - a1) * val - a1;

        // draws the max and min points
        pdialcolor(0, 100, 200);
        int xp = (int)(cx + sx / 2.0f + sx / 2.0f * sinf(angle1() / 180.0f * PI));
        int yp = (int)(cy + sy / 2.0f + sy / 2.0f * cosf(angle1() / 180.0f * PI));
        fl_pie(xp - 2, yp - 2, 4, 4, 0, 360);

        xp = (int)(cx + sx / 2.0f + sx / 2.0f * sinf(angle2() / 180.0f * PI));
        yp = (int)(cy + sy / 2.0f + sy / 2.0f * cosf(angle2() / 180.0f * PI));
        fl_pie(xp - 2, yp - 2, 4, 4, 0, 360);

        fl_push_matrix();

        fl_translate(cx + sx / 2, cy + sy / 2);
        fl_rotate(a - 90.0f);

        fl_translate(sx / 2, 0);

        fl_begin_polygon();
        if (!Controllable) {pdialcolor(0, 0, 255);}
        else { pdialcolor((midiControlled?255:100), 0, 0);}
        fl_vertex(-10, -4);
        fl_vertex(-10, 4);
        fl_vertex(0, 0);
        fl_end_polygon();
        fl_pop_matrix();} {}
  }
  Function {pdialcolor(int r,int g,int b)} {return_type void
  } {
    code {if (active_r())
            fl_color(r, g, b);
        else
            fl_color(160 - (160 - r) / 3, 160 - (160 - b) / 3, 160 - (160 - b) / 3);} {}
  }
  Function {value_cb2(void)} {return_type void
  } {
    code {tipwin->value(value());} {}
  }
  Function {value_cb(Fl_Widget*, void*data)} {return_type {static void}
  } {
    code {WidgetPDial *val = (WidgetPDial*)data;
        val->value_cb2();} {}
  }
  Function {tooltip(const char * c)} {return_type void
  } {
    code {tipwin->setText(c);
        textset = true;} {}
  }
  Function {reset(Fl_Widget* w, void* v)} {open return_type {static void}
  } {
    code {Fl_Valuator* dial = (Fl_Valuator*)w;
        dial->value((dial->maximum()-dial->minimum())/2);
        dial->do_callback();} {}
  }
  Function {setMidiControlled(bool b)} {open return_type void
  } {
    code {midiControlled = b;
        this->redraw();} {}
  }
  Function {checkSetParameter()} {open private return_type void
  } {
    code {if (!justCreated) return;
          if (param.duplicated) return;
            
            param = midiController::whichParameterDoesThisDialControl(this);
            if (param.paramName!=parID::PNullParam) {Controllable=true;}
            list<midiController>::iterator i;
            for(i=synth->assignedMidiControls.begin();i!=synth->assignedMidiControls.end();i++) {
               i->dialCreated(this);
            }
            if(this->active_r()==true) justCreated=false;} {selected
    }
  }
  decl {using Fl_Widget::callback;} {public
  }
  decl {bool textset;} {}
  decl {bool pos;} {}
  decl {double oldvalue;} {}
  decl {TipWin *tipwin;} {}
  decl {bool midiControlled; bool Controllable;} {public
  }
  decl {parameterStruct param;} {public
  }
  Function {stampa(Fl_Widget *w, void *v)} {open return_type {static void}
  } {
    code { WidgetPDial *p = (WidgetPDial*)w;
   if (!p->midiControlled) {
        synth->addController(1,p);
        p->setMidiControlled(true);
        midiccwindow->Show();
   } else {
        list<midiController>::iterator i;
        for(i=synth->assignedMidiControls.begin();i!=synth->assignedMidiControls.end();i++) {
            if (i->knob==p) {synth->removeController(&(*i));break;}
        }
        p->setMidiControlled(false);
        midiccwindow->updateRack();
   }} {}
  }
  decl {bool justCreated;} {}
} 
